Лабораторная работа №10

Задание 1
Наверняка вы думаете, что декораторы – это какая-то бесполезная вещь, которая вам никогда не пригодится, но тут вдруг на паре по математике преподаватель просит все посчитать число Фибоначчи для 100. Кто-то будет считать вручную (так точно не нужно), кто -то посчитает на калькуляторе, а кто-то думает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, потому что эффектная программа будет достаточно долго считаться, если ее просто так запустить. Но именно тут к вам, например, на помощь приходят декораторы, @lru_cache (он предназначен для решения задач динамического программирования, если простыми словами, то этот декоратор запоминает промежуточные результаты, и при рекурсивном вызове функция функции не будет считаться одним и тем же значением, а просто « возьмёт их из этого декоратора»). Вам нужно написать программу, которая будет считать числа Фибоначчи за 100, и запустить ее без этого декоратора и с ним посмотреть разницу во времени решения поставленной задачи. PS при запуске без декоратора можно долго не ждать, для видимости хватит 10 секунд ожидания.

from  functools import  lru_cache

@lru_cache(None)
def fibonacci(n):
    if n ==0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)

if __name__ =='__main__':
    print(fibonacci(100))

Результат.



Задание 2
Илья пишет свой сайт и ему необходимо провести минимальную проверку ввода данных пользователя при регистрации. Для этого он реализовал функцию, выводящую данные пользователя на экран, и решил, что будет проверять правильность введенных данных с помощью декоратора, но в этом ему потребовалась ваша помощь. Напишите декоратор для функции, который будет принимать параметры всех вызываемой функции (имя, возраст) и проверять, чтобы возраст был больше 0 и меньше 130. Далее из условия, что неважно, сколько пользователь ведет данные на сайте Илье, будут обрабатываться только первые 2 аргумента

def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age  =  'Недопустимый возраст'
        input_func(name, age)

    return output_func


@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")

if __name__ == '__main__' :
    personal_info('Владимир', 38)
    personal_info ('Александр', -5)
    personal_info('Петр', 138, 15, 48, 2)

Результат.



Задание 3
Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте возникла проблема, кто-то может попытаться сломать вашу функцию с получением данных для сайта. Эта функция работает только с целочисленными данными, а какой-то недохакер пытается все сломать и вместо нужного типа данных отправляет строку. Используйте исключения, чтобы данные неподходящего типа не сломали ваш сайт. Также дополнительно вы можете обернуть всю функцию кода в разделе «Попытка/исключение/наконец» для того, чтобы программа сообщила вам о том, что обнаружена какая-то ошибка или программа успешно выполнена.

def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')

if __name__ == '__main__':
    data([1, 15, 'Hello', ' 1 ', 'try', 'to', 'crash', 'your', 'site', 38, 45])

Результат.



Задание 4
Продолжая работу над сайтом, вы решили записать каждое соединение, которое будет сохраняться в, если в функции проверки имени при регистрации переданы строки более длинных десяти символов, а если имя имеет допустимую длину, то в консоль вывести «Успешную регистрацию»

class NegativeValueException(Exception):
    pass

def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регестрация')

if __name__ == '__main__':
    name = '1234567890'
    check_name(name)

Результат.



Задание 5
После запуска сайта вы поняли, что вам необходимо добавить логгер, для идентификации его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для данного создания две функции: init () (вызывается при создании класса декоратора в программе) и call () (вызывается при вызове декоратора). Создайте декоратор. Вы вводите все логи в консоль.

class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func  =  func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного выключения')

@SiteChecker
def site():
    print ('Усердная работа сайта')

if __name__ == '__main__' :
    print ('> Сайт запущен')
    site()
    print ('> Сайт выключен')

Результат.



Самостоятельная работа №10
Задание 1
Вовочка решил заняться спортивным программированием на Python, но для этого он должен знать, за какое время добиться успеха в своей программе. Он решил, что для этого ему идеально подойдет декоратор для функции, которая будет демонстрировать какое-то время эффективность той или иной функции. Помогите Вовочке в его начале и напишите такого декоратора. Подсказка: необходимо использовать модуль времени Декоратор необходимо использовать для этой функции.

import time

def time_of_func(func): # Устройство декоратора
    def wrapped(*args):
        start_time = time.perf_counter_ns()
        res = func(*args)
        print(time.perf_counter_ns() - start_time)
        return res
    return wrapped
@time_of_func # Декоратор
def fibonacci():

    fib1 = fib2 = 1
    temp = time.time()
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib1, end='\n')

if __name__ == '__main__':
    fibonacci()

Результат.



Вывод.
Узнал как пользоваться декоратором и что такое код "Обёртка"

Задание 2
Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав обучение, вы поняли, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой, что файлы пусты, и вы не добавили вводные данные для решения задач. После этого вы решили не просто считывать данные из файла, а всю лампочку оборачивать в исключения, чтобы избежать таких проблем. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то нужно вызвать закрывание («бросить скобки») и вывести в консоль «файл пустой», а если он не пустой, то вывести информацию из файла.

import os

def show_file(filename):
    try:
        if os.stat(filename).st_size > 0:
            print(f"{open(filename, encoding='utf-8').readlines()}")
        else:
            a = 1 / 0
    except:
        print("empty file")


show_file('input.txt')
show_file('rows_300.txt')

Результат.



Вывод.
Узнал подробнее о конструкции, попробую кроме.

Задание 3
Напишите функцию, которая будет складывать 2 и вводить пользовательское число, но если пользователь вводит символ или другой неподходящий тип данных, то в консоли выводится ошибка «Непод приходящим типом данных». Ожидалось число. Реализовать функциональные возможности программы необходимо с помощью метода «попробуй/исключи» и выбрав правильный тип исключения. Создавать собственные заключения нельзя. Проведем несколько тестов, в которых отклонений не наблюдается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль

try:
    data = int(input("Введите число: "))
    data = data + 2
    print(data)
except:
    print("Неподходящий тип данных. Ожидалось число")

Результат.



Вывод.
Узнал, как использовать освещение, попробуйте, кроме.

Задание 4
Создайте садовый декоратор, который будет использоваться для двух любых вами задуманных функций. Декораторы, которые ранее использовались в работе в отдаленных регионах. Результатом выполнения задачи будет: класс декоратора, два как-то изменения с этой функцией, скриншот консоли с завершенной программой и подробные комментарии, которые будут описывать работу вашего кода.

import time

def timer_func(func):
    # This function shows the execution time of
    # the function object passed
    def wrap_func(*args, **kwargs):
        t1 = time.time()
        result = func(*args, **kwargs)
        t2 = time.time()
        print(f'Function {func.__name__!r} executed in {(t2-t1):.4f}s')
        return result
    return wrap_func

@timer_func
def sum():
    sum = 1
    for i in range(0, 1000):
        sum += sum
        print(sum)

@timer_func
def sort_list(list):
    for i in range(len(list) - 1):
        for j in range(len(list) - i - 1):
            if list[j] > list[j + 1]:
                buff = list[j]
                list[j] = list[j + 1]
                list[j + 1] = buff
    print(list)


sum()
sort_list([1, 9, 5, 2, 7])

Результат.



Вывод.
Узнал как создать садовый сад

Задание 5
Создайте собственное соединение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые ранее применялись в работе в отдаленных регионах. Результатом выполнения задачи будет: класс исключения, код которого в двух местах использует это выражение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать вашу работу кода.

class NoMoreDmitrii(Exception):
    def __init__(self, message, extra_info):
        super().__init__(message)
        self.extra_info = extra_info

class AnotherError(Exception):
    def __init__(self,  *args):
        if args:
            self.message = args[0]
        else:
            self.message = None

    def __str__(self):
        if self.message:
            return "AnotherError, {0} ".format(self.message)
        else:
            return "Выход из диапазона допустимых значений у списка!"


def divide_numbers(a, b):
    if b == 0:
        raise NoMoreDmitrii("Деление на ноль невозможно", {"a": a, "b": b})
    return a / b

def one_hundred_procent_working_code(list, index):
    try:
        if index != 0:
            print(list[index - 1])
        else:
            raise AnotherError
    except AnotherError as e:
        print(f"Сообщение об ощибке: {e}")


try:
    result = divide_numbers(10, 0)
except NoMoreDmitrii as e:
    print(f"Сообщение об ошибке: {e}")
    print(f"Дополнительная информация: {e.extra_info}")

    try:
        one_hundred_procent_working_code([1,2,3], 0)
    except AnotherError as e:
        print(f"Сообщение об ошибке: {e}")

Результат.



Вывод.
Узнал как создавать собственные исключения
